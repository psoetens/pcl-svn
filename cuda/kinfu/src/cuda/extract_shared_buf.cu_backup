/*
* Software License Agreement (BSD License)
*
*  Copyright (c) 2011, Willow Garage, Inc.
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without
*  modification, are permitted provided that the following conditions
*  are met:
*
*   * Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*   * Redistributions in binary form must reproduce the above
*     copyright notice, this list of conditions and the following
*     disclaimer in the documentation and/or other materials provided
*     with the distribution.
*   * Neither the name of Willow Garage, Inc. nor the names of its
*     contributors may be used to endorse or promote products derived
*     from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
*  POSSIBILITY OF SUCH DAMAGE.
*
*  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
*/
#include "device.hpp"
#include "pcl/gpu/utils/device/funcattrib.hpp"
#include "pcl/gpu/utils/device/block.hpp"
#include "pcl/gpu/utils/device/warp.hpp"

namespace pcl
{
    namespace device
    {        
        ////////////////////////////////////////////////////////////////////////////////////////
        ///// Prefix Scan utility

        enum ScanKind { exclusive,  inclusive } ;

        template <ScanKind Kind , class T> 
        __device__ __forceinline__ T scan_warp ( volatile T *ptr , const unsigned int idx = threadIdx.x )
        {
            const unsigned int lane = idx & 31; // index of thread in warp (0..31)

            if ( lane >=  1) ptr [idx ] = ptr [idx -  1] + ptr [idx];
            if ( lane >=  2) ptr [idx ] = ptr [idx -  2] + ptr [idx];
            if ( lane >=  4) ptr [idx ] = ptr [idx -  4] + ptr [idx];
            if ( lane >=  8) ptr [idx ] = ptr [idx -  8] + ptr [idx];
            if ( lane >= 16) ptr [idx ] = ptr [idx - 16] + ptr [idx];

            if( Kind == inclusive ) 
                return ptr [idx ];
            else 
                return (lane > 0) ? ptr [idx - 1] : 0;
        }

        ////////////////////////////////////////////////////////////////////////////////////////
        ///// Full Volume Scan6

        enum 
        {
            CTA_SIZE_X = 32,
            CTA_SIZE_Y = 8,
            CTA_SIZE = CTA_SIZE_X * CTA_SIZE_Y
        };

        __shared__ int shared_count;
        __device__ int global_count = 0;
        __device__ int global_count_dd = 0;
        __device__ int output_count;
        __device__ unsigned int blocks_done = 0;


        const static int MAX_SHARED_COUNT = CTA_SIZE*3;
        __shared__ float storage[3][MAX_SHARED_COUNT];

        __shared__ int cta_buffer[CTA_SIZE];

        struct FullScan6
        {

            PtrStep<volume_elem_type> volume;
            float3 cell_size;


            mutable PtrSz<PointType> output;


            __device__ __forceinline__ float fetch(int x, int y, int z, int& weight) const
            {
                float tsdf;
                unpack_tsdf(volume.ptr(VOLUME_Y * z + y)[x], tsdf, weight);
                return tsdf;                
            }

            __device__ __forceinline__ void operator()()const
            {
                int x = threadIdx.x + blockIdx.x * CTA_SIZE_X;
                int y = threadIdx.y + blockIdx.y * CTA_SIZE_Y;

                if (threadIdx.x == 0 && threadIdx.y == 0 && threadIdx.z == 0)
                    shared_count = 0;

                if (__all(x >= VOLUME_X) || __all(y >= VOLUME_Y))
                    return;

                float3 V;
                V.x = (x + 0.5f) * cell_size.x;
                V.y = (y + 0.5f) * cell_size.y;

                int ftid = Block::flattenedThreadId();

                for(int z = 0; z < VOLUME_Z - 1; ++z)
                {
                    float3 points[3];
                    int local_count = 0;

                    if (x < VOLUME_X && y < VOLUME_Y)
                    {
                        int W;
                        float F = fetch(x, y, z, W);

                        if (W != 0 && F != 1.f)
                        {                            
                            V.z = (z + 0.5f) * cell_size.z;

                            //process dx
                            if (x + 1 < VOLUME_X)
                            {
                                int Wn;
                                float Fn = fetch(x+1, y, z, Wn);

                                if (Wn != 0 && Fn != 1.f)                                
                                    if ((F > 0 && Fn < 0) || (F < 0 && Fn > 0))
                                    {
                                        float3 p;
                                        p.y = V.y;
                                        p.z = V.z;

                                        float Vnx = V.x + cell_size.x;

                                        float d_inv = 1.f/(fabs(F) + fabs(Fn));
                                        p.x = (V.x * fabs(Fn) + Vnx * fabs(F)) * d_inv;

                                        points[local_count++] = p;                                
                                    }
                            } /* if (x + 1 < VOLUME_X) */

                            //process dy
                            if (y + 1 < VOLUME_Y)
                            {
                                int Wn;
                                float Fn = fetch(x, y+1, z, Wn);

                                if (Wn != 0 && Fn != 1.f)
                                    if ((F > 0 && Fn < 0) || (F < 0 && Fn > 0))
                                    {
                                        float3 p;
                                        p.x = V.x;
                                        p.z = V.z;

                                        float Vny = V.y + cell_size.y;

                                        float d_inv = 1.f/(fabs(F) + fabs(Fn));
                                        p.y = (V.x * fabs(Fn) + Vny * fabs(F)) * d_inv;

                                        points[local_count++] = p;
                                    }
                            }  /*  if (y + 1 < VOLUME_Y) */

                            //process dz
                            //if (z + 1 < VOLUME_Z) // guaranteed by loop
                            {
                                int Wn;
                                float Fn = fetch(x, y, z+1, Wn);

                                if (Wn != 0 && Fn != 1.f)
                                    if ((F > 0 && Fn < 0) || (F < 0 && Fn > 0))
                                    {
                                        float3 p;
                                        p.x = V.x;
                                        p.y = V.y;

                                        float Vnz = V.z + cell_size.z;

                                        float d_inv = 1.f/(fabs(F) + fabs(Fn));
                                        p.z = (V.x * fabs(Fn) + Vnz * fabs(F)) * d_inv;

                                        points[local_count++] = p;
                                    }
                            } /* if (z + 1 < VOLUME_Z) */
                        }  /* if (W != 0 && F != 1.f) */
                    }  /* if (x < VOLUME_X && y < VOLUME_Y) */

                    
                    int total_warp = __popc(__ballot(local_count > 0)) + __popc(__ballot(local_count > 1)) + __popc(__ballot(local_count > 2));                    
                    int offset;

                    int block_old_shared_count = shared_count;
                    __syncthreads();                    

                    if (total_warp > 0)
                    {
                        cta_buffer[ftid] = local_count;                        
                        offset = scan_warp<exclusive>(cta_buffer, ftid); 

                        int lane = Warp::laneId();
                        if (lane == 0)
                        {
                            int old_shared_count = atomicAdd(&shared_count, total_warp);
                            cta_buffer[ftid - lane] = old_shared_count;
                        }
                        int old_shared_count = cta_buffer[ftid - lane];
                        
                        //can write
                        if (old_shared_count + total_warp < MAX_SHARED_COUNT)
                        {
                            flush2shared(points, local_count, old_shared_count + offset);
                            total_warp = 0;
                        }
                    }               
                    __syncthreads();

                     if (ftid == 0)
                        printf("b....shared_count %d %d\n", shared_count, block_old_shared_count);

                     __syncthreads();


                    if (shared_count > MAX_SHARED_COUNT)
                    {
                        if (ftid == 0)
                            printf("flushing %d\n", shared_count);
                        
                        if (flush2global(block_old_shared_count))
                            break;

                        __syncthreads();

                        if (ftid == 0)
                            printf("after flushing %d %d\n", shared_count, global_count);
                    }

                    __syncthreads();

                    //repeat unsucessiful write 
                    if (total_warp > 0)
                    {   
                        int lane = Warp::laneId();
                        if (lane == 0)
                        {
                            int old_shared_count = atomicAdd(&shared_count, total_warp);
                            cta_buffer[ftid - lane] = old_shared_count;

                            printf("@%d - %d\n", old_shared_count, total_warp);
                        }
                        int old_shared_count = cta_buffer[ftid - lane];

                        //sure that shared memory is enought after flushing to global
                        flush2shared(points, local_count, old_shared_count + offset);
                    }            

                    __syncthreads();

                    if (ftid == 0)
                    {
                        //printf("....shared_count %d\n", shared_count);

                    }

                    //need in order to be sure that all unsucessiful writes before are completed
                    __syncthreads();

                } /* for(int z = 0; z < VOLUME_Z - 1; ++z) */


                ///////////////////////////
                // prepare for future scans
                if (ftid == 0)
                {                    
                    unsigned int total_blocks = gridDim.x * gridDim.y * gridDim.z;
                    unsigned int value = atomicInc(&blocks_done, total_blocks);

                    //last block
                    if (value == total_blocks - 1)
                    {
                        printf("global_count => %d\n", global_count);
                        output_count = min(output.size, global_count);
                        blocks_done = 0;
                        global_count = 0;  

                        printf("global_count_dd %d\n", global_count_dd);
                    }                                        
                }

            } /* operator() */

            __device__ __forceinline__ void flush2shared(float3 points[], int local_count, int offset) const
            {
                for(int l = 0; l < local_count; ++l)
                {
                    storage[0][offset+l] = points[l].x;
                    storage[1][offset+l] = points[l].y;
                    storage[2][offset+l] = points[l].z;
                }
            }

            __device__ __forceinline__ bool flush2global(int old_shared_count) const
            {   
                int ftid = Block::flattenedThreadId();
                int STRIDE = Block::stride();

                if (ftid == 0)
                {
                    int old_global = atomicAdd(&global_count, old_shared_count);
                    cta_buffer[0] = old_global;
                }
                __syncthreads();

                int old_global = cta_buffer[0];

                int new_length = min(output.size, old_global + old_shared_count);

                PointType *beg = output.data + old_global;
                PointType *end = output.data + new_length;
                               

                int index = ftid;
                for(PointType* pos = beg + ftid; pos < end; pos += STRIDE, index += STRIDE)
                {
                    float x = storage[0][index];
                    float y = storage[1][index];
                    float z = storage[2][index];
                    store_point_type(x, y, z, pos);                    
                }

                bool full = (old_global + old_shared_count) >= output.size;

                __syncthreads();

                if (ftid == 0)
                    shared_count = 0;

                __syncthreads();

                return full;
            }

            __device__ __forceinline__ void store_point_type(float x, float y, float z, float4* ptr) const { *ptr = make_float4(x, y, z, 0); }
            __device__ __forceinline__ void store_point_type(float x, float y, float z, float3* ptr) const { *ptr = make_float3(x, y, z); }
        };

        //__global__ void extractKernel(const FullScan26 fs) { fs(); }
        __global__ void extractKernel(const FullScan6 fs) { fs(); }
    }
}

size_t pcl::device::extractCloud(const PtrStep<volume_elem_type>& volume, const float3& volume_size, PtrSz<PointType> output)
{
    FullScan6 fs;
    fs.volume = volume;
    fs.cell_size.x = volume_size.x / VOLUME_X;
    fs.cell_size.y = volume_size.y / VOLUME_Y;
    fs.cell_size.z = volume_size.z / VOLUME_Z;
    fs.output = output;

    dim3 block(CTA_SIZE_X, CTA_SIZE_Y);
    dim3 grid(divUp(VOLUME_X, block.x), divUp(VOLUME_Y, block.y));

    cudaFuncSetCacheConfig(extractKernel, cudaFuncCachePreferL1);
    printFuncAttrib(extractKernel);

    extractKernel<<<grid, block>>>(fs);
    cudaSafeCall( cudaGetLastError() );    	  
    cudaSafeCall(cudaDeviceSynchronize());

    printf(">>> osz %d\n", output.size);

    int size;
    cudaSafeCall( cudaMemcpyFromSymbol(&size, output_count, sizeof(size)) );
    return (size_t)size;    
}



#if 0
struct FullScan26
{
    enum 
    {
        CTA_SIZE_X = 32,
        CTA_SIZE_Y = 8
    };
    PtrStep<volume_elem_type> volume;
    float3 cell_size;

    __device__ __forceinline__ float fetch(int x, int y, int z, int& weight) const
    {
        float tsdf;
        unpack_tsdf(volume.ptr(VOLUME_Y * z + y)[x], tsdf, weight);
        return tsdf;                
    }

    __device__ __forceinline__ void operator()()const
    {
        int x = threadIdx.x + blockIdx.x * CTA_SIZE_X;
        int y = threadIdx.y + blockIdx.y * CTA_SIZE_Y;

        if (x >= VOLUME_X || y >= VOLUME_Y)
            return;

        if (threadIdx.x == 0 && threadIdx.y == 0)
            shared_count = 0;

        float3 V;
        V.x = (x + 0.5f) * cell_size.x;
        V.y = (y + 0.5f) * cell_size.y;

        for(int z = 0; z < VOLUME_Z - 1; ++z)
        {
            int W;
            float F = fetch(x, y, z, W);

            if (W == 0 || F == 1.f)
                continue;

            V.z = (z + 0.5f) * cell_size.z;

            //front 3x3
            int dz = 1;                
            for(int dy = -1; dy < 2; ++dy)
            {
                if (y + dy >= VOLUME_X || y + dy < 0)
                    continue;

                for(int dx = -1; dx < 2; ++dx)
                {
                    if (x + dx >= VOLUME_X || x + dx < 0)
                        continue;

                    int Wn;
                    float Fn = fetch(x+dx, y+dy, z+dz, Wn);

                    if (Wn == 0 || Fn == 1.f)
                        continue;

                    if ((F > 0 && Fn < 0) || (F < 0 && Fn > 0))
                    {
                        float3 Vn = V;
                        Vn.x += dx * cell_size.x;
                        Vn.y += dy * cell_size.y;
                        Vn.z += dz * cell_size.z;

                        float d_inv = 1.f/(fabs(F) + fabs(Fn));
                        float3 p = (V * fabs(Fn) + Vn * fabs(F)) * d_inv;

                        if(!store(p))
                            return;
                    }
                }
            }

            //middle 3x1 + 1
            dz = 0;
            for(int dy = 0; dy < 2; ++dy)
            {
                if (y + dy >= VOLUME_Y)
                    continue;

                for(int dx = -1; dx < dy * 2; ++dx)
                {
                    if (x + dx >= VOLUME_X || x + dx < 0)
                        continue;

                    int Wn;
                    float Fn = fetch(x+dx, y+dy, z+dz, Wn);

                    if (Wn == 0 || Fn == 1.f)
                        continue;

                    if ((F > 0 && Fn < 0) || (F < 0 && Fn > 0))
                    {
                        float3 Vn = V;
                        Vn.x += dx * cell_size.x;
                        Vn.y += dy * cell_size.y;
                        Vn.z += dz * cell_size.z;

                        float d_inv = 1.f/(fabs(F) + fabs(Fn));
                        float3 p = (V * fabs(Fn) + Vn * fabs(F)) * d_inv;

                        if(!store(p))
                            return;
                    }                 
                }
            }

        } /* for(int z = 0; z < VOLUME_Z - 1; ++z) */
    } /* operator() */

    __device__ __forceinline__ bool store(const float3& p) const
    {                
        //__ffs __ballot(1);

        return true;
    }
};

#endif  